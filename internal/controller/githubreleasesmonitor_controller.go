package controller

import (
	"context"
	"encoding/json"
	"io"
	"net/http"
	"time"

	monitoringv1 "githubreleasesmonitor/project/api/v1"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/tools/record"
	ctrl "sigs.k8s.io/controller-runtime" // added
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/reconcile" // added
)

// GitHubReleasesMonitorReconciler reconciles a GitHubReleasesMonitor object
type GithubReleasesMonitorReconciler struct {
	client.Client
	Scheme   *runtime.Scheme
	Recorder record.EventRecorder
}

//+kubebuilder:rbac:groups=monitoring.your.domain,resources=githubreleasesmonitors,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=monitoring.your.domain,resources=githubreleasesmonitors/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=monitoring.your.domain,resources=githubreleasesmonitors/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO: Modify the Reconcile function to compare the state specified by
// the GitHubReleasesMonitor object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
func (r *GithubReleasesMonitorReconciler) Reconcile(ctx context.Context, req reconcile.Request) (reconcile.Result, error) {
	log := log.FromContext(ctx)

	// Fetch the GitHubReleasesMonitor instance
	var monitor monitoringv1.GithubReleasesMonitor
	if err := r.Get(ctx, req.NamespacedName, &monitor); err != nil {
		log.Error(err, "unable to fetch GitHubReleasesMonitor")
		return reconcile.Result{}, client.IgnoreNotFound(err)
	}

	// Determine monitorFrom time
	var monitorFromTime time.Time
	if monitor.Spec.MonitorFrom == "now" {
		monitorFromTime = monitor.CreationTimestamp.Time
	} else {
		parsedTime, err := time.Parse(time.RFC3339, monitor.Spec.MonitorFrom)
		if err != nil {
			log.Error(err, "invalid monitorFrom date")
			return reconcile.Result{}, err
		}
		monitorFromTime = parsedTime
	}

	// Fetch releases from the GitHub repository
	resp, err := http.Get(monitor.Spec.URL)
	if err != nil {
		log.Error(err, "unable to fetch GitHub releases")
		return reconcile.Result{}, err
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Error(err, "unable to read response body")
		return reconcile.Result{}, err
	}

	var releases []struct {
		TagName     string    `json:"tag_name"`
		PublishedAt time.Time `json:"published_at"`
	}
	if err := json.Unmarshal(body, &releases); err != nil {
		log.Error(err, "unable to unmarshal JSON")
		return reconcile.Result{}, err
	}

	// Process releases
	var newReleases []string
	for _, release := range releases {
		if release.PublishedAt.After(monitorFromTime) {
			newReleases = append(newReleases, release.TagName)
			// Create GitHubRelease CR if it does not exist
			githubRelease := &monitoringv1.GithubReleasesMonitor{
				ObjectMeta: metav1.ObjectMeta{
					Name:      release.TagName,
					Namespace: monitor.Namespace,
				},
				Spec: monitoringv1.GithubReleasesMonitorSpec{
					URL:         release.TagName,
					MonitorFrom: release.PublishedAt.Format(time.RFC3339),
				},
			}
			if err := controllerutil.SetControllerReference(&monitor, githubRelease, r.Scheme); err != nil {
				log.Error(err, "unable to set controller reference for GitHubRelease")
				return reconcile.Result{}, err
			}
			if err := r.Create(ctx, githubRelease); client.IgnoreAlreadyExists(err) != nil {
				log.Error(err, "unable to create GitHubRelease")
				return reconcile.Result{}, err
			}
		}
	}

	// Update the status of GitHubReleasesMonitor
	monitor.Status.ReleasesFound = newReleases
	monitor.Status.LastChecked = time.Now().UTC().Format(time.RFC3339)
	monitor.Status.MonitorFromTimestamp = monitorFromTime.UTC().Format(time.RFC3339)

	if err := r.Status().Update(ctx, &monitor); err != nil {
		log.Error(err, "unable to update GitHubReleasesMonitor status")
		return reconcile.Result{}, err
	}

	return reconcile.Result{RequeueAfter: 1 * time.Hour}, nil
}

// SetupWithManager sets up the controller with the Manager.
func (r *GithubReleasesMonitorReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&monitoringv1.GithubReleasesMonitor{}).
		Owns(&monitoringv1.GithubReleasesMonitor{}).
		Complete(r)
}
