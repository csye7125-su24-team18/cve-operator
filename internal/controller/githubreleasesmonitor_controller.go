package controller

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"regexp"
	"strings"
	"time"

	"net/url"

	githubreleasev1 "githubreleasesmonitor/project/api/v1" // Import the new GithubRelease API
	monitoringv1 "githubreleasesmonitor/project/api/v1"

	"github.com/go-logr/logr"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/tools/record"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"
)

// GithubReleasesMonitorReconciler reconciles a GithubReleasesMonitor object
type GithubReleasesMonitorReconciler struct {
	client.Client
	Scheme   *runtime.Scheme
	Recorder record.EventRecorder
}

//+kubebuilder:rbac:groups=monitoring.githubreleasesmonitor.githubreleasesmonitor,resources=githubreleasesmonitors,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=monitoring.githubreleasesmonitor.githubreleasesmonitor,resources=githubreleasesmonitors/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=monitoring.githubreleasesmonitor.githubreleasesmonitor,resources=githubreleasesmonitors/finalizers,verbs=update
//+kubebuilder:rbac:groups=githubreleasesmonitor.githubreleasesmonitor.githubreleasesmonitor,resources=githubreleases,verbs=get;list;watch;create;update;patch;delete

func (r *GithubReleasesMonitorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	log := log.FromContext(ctx)

	// Fetch the GithubReleasesMonitor instance
	var monitor monitoringv1.GithubReleasesMonitor
	if err := r.Get(ctx, req.NamespacedName, &monitor); err != nil {
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}

	// if err := validateURL(monitor.Spec.URL); err != nil {
	// 	log.Error(err, "Invalid URL in GithubReleasesMonitor", "URL", monitor.Spec.URL)
	// 	// Update the status to reflect the error
	// 	monitor.Status.LastChecked = time.Now().UTC().Format(time.RFC3339)
	// 	monitor.Status.ReleasesFound = []string{"Error: Invalid URL"}
	// 	if updateErr := r.Status().Update(ctx, &monitor); updateErr != nil {
	// 		log.Error(updateErr, "Failed to update GithubReleasesMonitor status")
	// 	}
	// 	return ctrl.Result{RequeueAfter: time.Hour}, nil
	// }
	// Determine monitorFrom time
	monitorFromTime, err := getMonitorFromTime(&monitor)
	if err != nil {
		log.Error(err, "invalid monitorFrom date")
		return ctrl.Result{}, err
	}

	// Fetch releases from the GitHub repository
	releases, err := fetchGitHubReleases(monitor.Spec.URL)
	if err != nil {
		log.Error(err, "unable to fetch GitHub releases")
		return ctrl.Result{}, err
	}

	log.Info("Processing GithubReleasesMonitor", "Name", monitor.Name, "URL", monitor.Spec.URL)
	// Process releases
	var newReleases []string
	for _, release := range releases {
		log.Info("Processing release", "TagName", release.TagName, "HTMLURL", release.HTMLURL)
		if release.PublishedAt.After(monitorFromTime) {
			newReleases = append(newReleases, release.TagName)

			if err := r.createOrUpdateGitHubReleaseCR(ctx, log, &monitor, &release); err != nil {
				log.Error(err, "unable to create or update GitHubRelease CR")
				return ctrl.Result{}, err
			}
		}
	}

	// Update the status of GithubReleasesMonitor
	if err := r.updateMonitorStatus(ctx, &monitor, newReleases, monitorFromTime); err != nil {
		log.Error(err, "unable to update GithubReleasesMonitor status")
		return ctrl.Result{}, err
	}

	return ctrl.Result{RequeueAfter: time.Minute * 2}, nil
}

func (r *GithubReleasesMonitorReconciler) createOrUpdateGitHubReleaseCR(ctx context.Context, log logr.Logger, monitor *monitoringv1.GithubReleasesMonitor, release *GitHubRelease) error {
	githubReleaseName := fmt.Sprintf("release-%s", strings.ToLower(strings.ReplaceAll(release.TagName, ".", "-")))
	var githubRelease githubreleasev1.GithubRelease
	err := r.Get(ctx, types.NamespacedName{Name: githubReleaseName, Namespace: monitor.Namespace}, &githubRelease)
	log.Info("Creating/Updating GitHubRelease CR", "Name", githubReleaseName, "ReleaseURL", release.HTMLURL, "TagName", release.TagName)
	sanitizedName := sanitizeName(release.TagName)
	if err != nil {
		if errors.IsNotFound(err) {
			// Create new GitHubRelease CR
			githubRelease = githubreleasev1.GithubRelease{
				ObjectMeta: metav1.ObjectMeta{
					Name:      sanitizedName,
					Namespace: monitor.Namespace,
				},
				Spec: githubreleasev1.GithubReleaseSpec{
					ReleaseURL: release.HTMLURL,
					TagName:    release.TagName,
				},
			}
			log.Info("GitHubRelease object to be created", "GitHubRelease", fmt.Sprintf("%+v", githubRelease))
			if err := controllerutil.SetControllerReference(monitor, &githubRelease, r.Scheme); err != nil {
				return fmt.Errorf("unable to set controller reference for GitHubRelease: %w", err)
			}
			print("Creating GitHubRelease CR")
			if err := r.Create(ctx, &githubRelease); err != nil {
				println("Error creating GitHubRelease CR", err)
				return err
			}
		} else {
			return err
		}
	} else {
		// GitHubRelease CR already exists, update if necessary
		githubRelease.Spec.ReleaseURL = release.HTMLURL
		githubRelease.Spec.TagName = release.TagName
		if err := r.Update(ctx, &githubRelease); err != nil {
			return err
		}
	}

	return nil
}

func (r *GithubReleasesMonitorReconciler) updateMonitorStatus(ctx context.Context, monitor *monitoringv1.GithubReleasesMonitor, newReleases []string, monitorFromTime time.Time) error {
	monitor.Status.ReleasesFound = newReleases
	monitor.Status.LastChecked = time.Now().UTC().Format(time.RFC3339)
	monitor.Status.MonitorFromTimestamp = monitorFromTime.UTC().Format(time.RFC3339)

	return r.Status().Update(ctx, monitor)
}

func getMonitorFromTime(monitor *monitoringv1.GithubReleasesMonitor) (time.Time, error) {
	if monitor.Spec.MonitorFrom == "now" {
		return monitor.CreationTimestamp.Time, nil
	}
	return time.Parse(time.RFC3339, monitor.Spec.MonitorFrom)
}

type GitHubRelease struct {
	TagName     string    `json:"tag_name"`
	PublishedAt time.Time `json:"published_at"`
	HTMLURL     string    `json:"html_url"`
}

func fetchGitHubReleases(url string) ([]GitHubRelease, error) {
	resp, err := http.Get("https://api.github.com/repos/CVEProject/cvelistV5/releases")
	if err != nil {
		return nil, fmt.Errorf("failed to fetch releases: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	contentType := resp.Header.Get("Content-Type")
	if !strings.HasPrefix(contentType, "application/json") {
		return nil, fmt.Errorf("unexpected content type: %s", contentType)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	var releases []GitHubRelease
	if err := json.Unmarshal(body, &releases); err != nil {
		return nil, fmt.Errorf("failed to parse JSON: %w", err)
	}

	return releases, nil
}

// validateURL checks if the given string is a valid URL.
func validateURL(rawURL string) error {
	_, err := url.ParseRequestURI(rawURL)
	if err != nil {
		return fmt.Errorf("invalid URL: %w", err)
	}
	return nil
}

func sanitizeName(name string) string {
	// Convert to lower case
	name = strings.ToLower(name)
	// Replace invalid characters with '-'
	invalidChars := regexp.MustCompile(`[^a-z0-9-]+`)
	name = invalidChars.ReplaceAllString(name, "-")
	// Ensure the name starts and ends with an alphanumeric character
	name = strings.Trim(name, "-")
	return name
}

// SetupWithManager sets up the controller with the Manager.
func (r *GithubReleasesMonitorReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&monitoringv1.GithubReleasesMonitor{}).
		Owns(&githubreleasev1.GithubRelease{}).
		Complete(r)
}
